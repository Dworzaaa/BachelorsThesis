% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=B,english]{FITthesis}[2012/10/20]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
% \usepackage[latin2]{inputenc} % LaTeX source encoded as ISO-8859-2
% \usepackage[cp1250]{inputenc} % LaTeX source encoded as Windows-1250

\usepackage{graphicx} %graphics files inclusion
% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% EDIT THIS
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\department{Department of software engineering}
\title{Specialized Information System Maintaining Patients Participating in Epileptosurgical Programme – Reporting Module}
\authorGN{Martin} %author's given name/names
\authorFN{Dvořáček} %author's surname
\author{Martin Dvořáček} %author's name without academic degrees
\authorWithDegrees{Martin Dvořáček} %author's name with academic degrees
\supervisor{Ing. Petr Ježdík Ph.D.}
\acknowledgements{THANKS}
\abstractEN{Summarize the contents and contribution of your work in a few sentences in English language.}
\abstractCS{V n{\v e}kolika v{\v e}t{\' a}ch shr{\v n}te obsah a p{\v r}{\' i}nos t{\' e}to pr{\' a}ce v {\v c}esk{\' e}m jazyce.}
\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{Replace with comma-separated list of keywords in Czech.}
\keywordsEN{Replace with comma-separated list of keywords in English.}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license


\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\chapter{Introduction}
The reporting module, part of the GENEPI - the information system, adds an important function to this software. Thanks to this module the user will be able to export data saved in the system to sundry formats. This is useful for the doctors that take care of patients with epilepsy, as well as for the researchers that make analysis above the data from this system. In this thesis I'll describe the design and implementation of the reporting module, as well the process of final testing of this product.

\chapter{Analysis and design}
The repoting module, as well as the whole information system, was designed given the requested robustness, accessibility, reliability and the cleanness of the code. GENEPI has a three-tier architecture, uses access according to the roles of the users via Spring Security and thanks to the optimalized data layer it saves the computing resources.

Due to the fact, that users, who should work with the exported data, have different access levels and different requirements on the format of the exported data, there is a need to make the modul to be able to anonymize sensitive data as well as to export data to different formats. The contracting authority also requested that the user could choose which data does he want to export. For research purposes is also important to determine, if data that should be exported, contain only patients, whose data were verified by the povereny user.

\section{GENEPI - the information system}
That the reader could fully understand the functioning of the reporting module, first of all it is needed to introduce the information system that it extends. GENEPI - the information system was being created within the subjects BI-SP1 and BI-SP2 on the Czech Technical University, Faculty of Information Technologies in the school year 2012/2013 as a student's project. It should replace the original information system that was used in the Faculty Hospital Motol in Prague for maintaining patients in epileptosurgical programme. The main reasons for replacing the original system was a fact, that it didn't comply with the current requirements of the medics, contained bugs and its design wasn't optimal. GENEPI IS is being developed in the java programming language, using frameworks Spring 3 and Hibernate 4.2. Front-end part is realized via JSP, using HTLM5, Javascript and CSS. Libraries that were used to ease the programming of the front-end were Twitter Bootstrap and jQuery. As a database has been chosen MySQL 5.5 and as an application server Apache Tomcat 7. All of the used libraries are distributed under some kind of free license. The GENEPI is a bilingual software due to the expected deployment in the Miami Children's hospital in Florida, the United States of America. Languages that are currently supported, are czech and english, nevertheless thanks to the sui         * TODO
tably implemented localization it is easy to extend the application and add any other language. During the whole period of the programming of the system, the team consulted the approach often  and regularly with contracting authority, to fully meet the needs of the medics.

\section{Design of the reporting module}
Architecture of the reporting module doesn't differ from the architecture of the rest of the information system. Thanks to this, I could guarantee the robustness and the security of this module. It has also provided me an easy and elegant way to access the other components in the system.



In this tree diagram you can see the parts of the IS, ktere se tykaji of reporting module:

	\dirtree{%
		.1 Backend.
		.2 src.
		.3 main.
		.4 java\DTcomment{java classes}.
		.5 cz.
		.6 cvut.
		.7 fit.
		.8 genepi.
		.9 businessLayer.
		.10 service\DTcomment{interface of the service classes}.
		.10 serviceImpl\DTcomment{implementation of service}.
		.9 dataLayer.
		.10 DAO\DTcomment{interface of the DAO}.
		.10 DAOImpl\DTcomment{implementation of DAO}.
		.10 entity\DTcomment{entities}.		
		.9 presentationLayer\DTcomment{controllers}.
		.4 resources\DTcomment{properties files}.
		.4 webapp\DTcomment{files for front-end}.
		.5 resources\DTcomment{front-end libraries, pictures and other media}.
		.5 WEB-INF.
		.6 tags\DTcomment{templates for jsp}.
		.6 views\DTcomment{jsp files}.
	}


\subsection{Design of the back-end part}
Back-end part of the reporting module was designed to follow the three-tier architecture of the rest of the system. Thus the classes that this modul uses, are devided into three different packages. Every package contains classes that belong to the same tier. These packages are called Presentation layer, Data layer and Business Layer.

\subsubsection{Presentation layer}
In the presentation layer there is a controller - a Spring MVC component that calls function according to the  HTML request and its URL that is mapped to a particular function. This function executes simple operations such as verification of the passed parameters and calls to the other layers. The results of the functions from other layers may be saved to the org.springframework.ui.Model object and passed to the front-end. This layer never executes any more complicated actions, as those should be done within the business layer. Functions of the controller usually return the name of the view that should be displayed to the user.
\subsubsection{Data layer}
This layer contains three packages - DAO, DAOImpl and entity. In DAO package, there are interfaces of the data access objects stored, in DAOImpl are the classes that implement the interfaces from DAO package and finally in entity package, we can find the entity classes.
In DAOImpl classes you can find the functions, that are used to access the database and to get some data from it. There is direct use of hibernate functions or queries in HQL.
In entity classes is described, how the structures of the tables in the database look like. Every entity contains a property for every single column of the table. The type of this variable must match the type of the column of the table. Every property has to have a getter and a setter as well. Thanks to anotations from javax.* and org.hibernate.validator.constrains.* it is possible to check the requirements for perks of the input that should be saved to the database, ie. minimal or maximal size, regexp pattern or if the input may be blank. Very important is hibernate anotation @Column, as it describes the mapping of the property to the certain table in the database.

I would like to point out the generic GenericDAO and GenericDAOImpl classes that have been implemented.
These are abstract classes that were implemented to ease the develomplent team the programming of other DAO and DAOImpl classes. In the GenericDAOImpl class there are implemented the most used methods, that may be used by any entity such as save, delete, getCount, getCountOfUnhidden, findByID and others methods. The other DAO and DAOImpl methods then extend these generic classes so then it's not needed to implement these basic functions to every single class and the programmer had to programme only those functions, that were unique for that certain class.
\subsubsection{Business layer}
There are three packages in in this tier - concretly those are service, serviceImpl and VO. Service contains interfaces whereas in serviceImpl are the classes that implement the them. It is OBDOBNE as in the data tier. The third package - VO - contains classes, that are used to transform classes from the form in which the data come from the database - in enitity classes - to the form, that is more VHODNY for work and presentation of those data. This is the the reason why these are col VO classes.

\subsection{Design of the frontend part}


	\chapter{Realisation}
All that will be described in this chapter NACHAZI SE in the business layer. The standard approach during performing an export is NASLEDUJICI:

\begin{enumerate}
\item{ The user chooses in the export view the properties that wants to include to the exported file, the format, anonymization option and hits the export button }
\item{ PatientExportPOST method in PatientController entity is called and according to the given parameters is calls method to export the data to the right format. It also chcecks if the data should be anonymized and if the user isn't authorized to see sensitive data, then it sets the anonymize flag to true automatically. All given parameters with all those information are passed to called export function in the Bussines tier.}
\item{ In this step we've moved from Presentation tier to Business tier, where one of the methods for export to certain format was called. This is the part, where the data is written to the file itself. The program iterates through all the patient that user wanted to export and POSTUPNE prints out their data.
}

\end{enumerate}


OBRAZEK DIAGRAMU

popsat obecny postupy pri realizaci a na co se zvlast kladl duraz
\section{Customization of the export}
There was a strong demand from the contracting authority to create module that would  let the user to customize the report. This is because every patient can have filled in fifteen cards. This means circa than 340 properties that can be stored for every single patient. Nevertheless not all of them are needed to be exported in certain situations. Therefore was needed to implement some solution, that would allow user to select only those cards or properties of those cards, that should be exported.
Vzhledem k high amount of those properties, it was quite challenging to create solution, that would meet the requirements and will be user-friendly at the same time. Treeview on the fron-end and special entity on the back-end.

On the front-end there was a implemented a customized treeview, where every item has a checkbox. Patient's cards are represented by the nodes, whereas porperties of these cards are represented by the leaves of this tree. By checking and unchecking these items, the user can choose, what all should be involved in the exported data.
Here I attach a simple example of the treeview I was writting about:


	\dirtree{%
		.1 Anamnesis\DTcomment{anamnesis card}.
		.2 Neco.
		.2 Neco jineho.
		.1 Seizures\DTcomment{seizure card}.
		.2 Seizure property.
		.2 Another seizure property.
	}

After confirming the export form, the state of the treeview is saved to an entity called ExportParams. This entity has a boolean property for every single value from the treeview in export form. Thanks to this, I am able to determine, which properties the user wanted to export and which didn't. It gives me another advantage - I can save the current setting of the treeview for later usage, but I will speak about this feature later.
 
OBRAZEK TREE VIEW
\section{Export to the particular formats}
During the  programming of the classes that procure the logic of the reporting, I was trying to use the fact, that there already exist java libraries that can export data to docx, pdf, xls and csv formats. I also avoided the duplication of the code by transforming data from one format to another. Thanks to these measures, it is much easier to do changes in the code of the classes that handle export itself and it also eases the understanding of the code to anybody, who would read it.
\subsection{txt}
Export to the text format is realized by components form java.io.* package. Specifically java.io.FileOutputStream, java.io.OutputStreamWriter and java.io.BufferedWriter. Output is encoded to UTF-8 format. Every property is printed out to a new line, sections are delimited by dash lines, star lines or empty lines.
\subsection{docx}
Export to the docx format was not as easy as to the txt, so I decided to look up suitable libraries, compare them and use that one, which would best suit my needs. After researching the possible solutions I ended up with two libraries - apache POI and docx4j.
o POI
o docx4j
Proc jsem se rozhodl o docx4j
\subsection{xls}
As well as for the docx format, I used that there were already programmed libraries for export to xls.
POI 
Neco dalsiho
Proc jsem se rozhodl pro POI
\subsection{pdf}
There are of course java libraries for export data to pdf as well, nevertheless I've chosen different approach. While I already had implemented the export to docx, I've chosen not to implement export to pdf, but to create file with data exported to docx and using the classes form apache.poi.xwpf.converter.* package convert this file to pdf.
K cemu je to dobry
\subsection{csv}
Before I started to implement the export to csv format, I was also thinking, if I should implement whole logic of export to csv, but then I decided to proceed obdobne as in the case of implementation of the export to pdf. Nevertheless now I don't use file with data exported to docx, but file with export to xls, as this format can be easily transformed to csv and vice versa. During the export to csv I create xls file with exported data at first and then I walk through this file and print out the values to the file via the classes from java.io.* package. These are the same classes, that have been used in the export to txt. Based on the requirements of the contracting authority, the comma, as a standard delimiter in csv format, has been replaced with semicolon. The main reason of this change was a fact, that every card, that patient may have, contains comment, which is a text, which may also contain commas. As the semicolon is a much less used character in the sentences, it was decided to use it as a delimiter. Otherwise the report could look confusingly for the user
\section{Security and anonymization}
In GENEPI - the information system there are 3 main levels of an access, according to the visibility of the patient's data.
\begin{enumerate}
\item{Administrators}

Administrators don't have any access to the patient's data. They are not even able to access the URL to view or export these data.
\item{Researchers}

Researchers have limited access to patient's data - they are not allowed to see sensitive data.
\item{Doctors}
\end{enumerate}
Doctors have full access to patient's data

Because of this fact, it was needed to implement some way, how to anonymize the exported data. I have implemented two types of anonymization - volitelnou a povinnou.

Volitelna anonymization is accessable only to doctors. Before they commit the expoert, they can choose if they want to anonymize the data. This could be usefull for example in the situations, when the doctor needs to provide the data to somebody, who normally doesn't have an access to the system and zaroven can't see the sensitive informations. On the other hand, the doctor still has a possibility to export unanonymized data, which might be usefull for the medical purposes.
Povinna anonymization is done automatically, when somebody,who doesn't have dostatecne pristupove upravneni wants to export data. This feature will prevent anybody unauthorized from seeing the sensitive data.
\end{enumerate}
\section{Export of the verified patients}
\section{Custom sets}
\chapter{Testing}
\chapter{Conclusion}

\bibliographystyle{csn690}
\bibliography{mybibliographyfile}

\setsecnumdepth{all}
\appendix

\chapter{Acronyms}
% \printglossaries
\begin{description}
	\item[GUI] Graphical user interface
	\item[XML] Extensible markup language
	\item[HQL] Hibernate query language
	\item[VO] View object
\end{description}


\chapter{Contents of enclosed CD}

%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 exe\DTcomment{the directory with executables}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{implementation sources}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the thesis text in PDF format}.
		.2 thesis.ps\DTcomment{the thesis text in PS format}.
	}
\end{figure}

\end{document}
